//
// ****************************************************************************
// * Copyright (C) 2017, International Business Machines Corporation          *
// * All rights reserved.                                                     *
// ****************************************************************************
//

namespace com.ibm.streamsx.objectstorage.swift.test;

use com.ibm.streamsx.objectstorage.swift::*;

/**
 * This sample application tests the time to write objects to Object Storage
 * and the time to read objects from Object Storage.
 * The test data is created in memory of an operator before starting the time measurement.
 * One tuple send to the SwiftSink represents the object to be created on Object Storage.
 * When all objects have been created, then the read performance measurement starts and
 * all objects are read from Object Storage and tuples are discarded.
 */
@threading(model=manual)
composite PeformanceTest {

	param
		expression<rstring> $objectStorageUserID:    getSubmissionTimeValue("ObjectStorage-UserId");
		expression<rstring> $objectStoragePassword:  getSubmissionTimeValue("ObjectStorage-Password");
		expression<rstring> $objectStorageProjectID: getSubmissionTimeValue("ObjectStorage-ProjectId");

		expression<rstring> $objectStorageContainer: getSubmissionTimeValue("ObjectStorage-Container", "streams-test");
		expression<rstring> $objectStorageAccessPoint: getSubmissionTimeValue("ObjectStorage-AccessPoint", "dal.objectstorage.open.softlayer.com");
		expression<int32> $numChannels: (int32) getSubmissionTimeValue("numChannels", "1");
		expression<boolean> $cleanup : (boolean)getSubmissionTimeValue("cleanup", "false");

	graph
	
		/*
		 * Read the test configuration file
		 * Specifies number of objects and object size per test sequence
		 */	
		stream<int32 numObjects, int32 numBytes> CfgStream = FileSource() {
			param
				file : getThisToolkitDir()+"/etc/test_config.csv";
				parsing : permissive;
			config placement: partitionColocation("TEST-CONFIG"), partitionExlocation("TESTAPP");
		}
	
		@parallel(width = $numChannels, broadcast=[CfgStream])
		() as Tester = Test(CfgStream) {
			param
				objectStorageUserID : $objectStorageUserID;
				objectStoragePassword : $objectStoragePassword; 
				objectStorageProjectID : $objectStorageProjectID;
				objectStorageContainer : $objectStorageContainer + (rstring)getChannel();
				objectStorageAccessPoint: $objectStorageAccessPoint;
				cleanup: $cleanup;
			
		}		

	config restartable: false;
}

composite Test (input CfgStream)
{
	param
		expression<rstring> $objectStorageUserID;
		expression<rstring> $objectStoragePassword;
		expression<rstring> $objectStorageProjectID;
		expression<rstring> $objectStorageContainer;
		expression<rstring> $objectStorageAccessPoint;
		expression<boolean> $cleanup;
		

	graph
	
		/*
		 * Setup bucket and clean-up
		 */
		(
		stream<I> CfgStream1
		) as PrepareTest = Custom(CfgStream as I) {
			logic
			state: {
				mutable boolean res = initialize($objectStorageUserID, $objectStoragePassword, $objectStorageProjectID); // init Swift client
				mutable boolean isFirstTuple = true;
			}
			onTuple I: {
				if (isFirstTuple) {
					isFirstTuple = false;
					printStringLn ("["+(rstring)getChannel()+"]"+"Setup ...");										
					createContainer($objectStorageContainer);
					deleteAllObjects($objectStorageContainer);
				}
				submit (I, CfgStream1);
			}
			config placement: partitionColocation("TEST-CONFIG");
		}

		stream<I> GatedCfgStream = Gate(CfgStream1 as I; Control) {                                                                                 
			param
				maxUnackedTupleCount : 1u; // allow only 1 tuple to go through at a time
			config
				placement: partitionColocation("TEST-CONFIG");
				threadedPort : queue(Control, Sys.Wait);
		}

		(
		stream<rstring objectName, rstring data> DataString as O;
		stream<int32 numObjects> NumObjects
		) as DataGen = Custom(GatedCfgStream as I) {
			logic
			state: {
				mutable O otuple = {};				
				mutable int32 numDataSet = 0;
				mutable int32 outRolling = 0;
				mutable boolean firstTuple = true;
				mutable list<O> dataSets = [];
				mutable int32 activeDataSetIdx = 0;
			}
			onTuple I: {
				printStringLn ("["+(rstring)getChannel()+"]"+"["+(rstring)I.numObjects+","+(rstring)I.numBytes+"] --------");
				submit ({numObjects=I.numObjects}, NumObjects); // send cfg tuple
				
				for (int32 dataSetCounter in range(I.numBytes)) {
					otuple.data += "x";
					numDataSet = dataSetCounter;
				}
				outRolling++;

				for (int32 filenum in range(I.numObjects)) {
					otuple.objectName= "testFile_" + (rstring)outRolling + "_" + (rstring)filenum + ".bin";
					submit (otuple, O); // send data
					submit(Sys.WindowMarker, O); // close
				}
				otuple.data = "";
			}
			config placement: partitionColocation("PERFTEST"+(rstring)getChannel()), partitionExlocation("TESTAPP");
		}	
		
		stream<rstring objectName, uint64 objectSize> ObjStSink = SwiftObjectStorageSink(DataString) { 
			param
				userID: $objectStorageUserID;
				password: $objectStoragePassword;
				projectID: $objectStorageProjectID;
				accessPoint: $objectStorageAccessPoint;
				objectNameAttribute: objectName;
				container: $objectStorageContainer;
				vmArg : "-Xmx4096m";
				genOpenObjPunct: true;
				closeOnPunct: true;
			config placement: partitionColocation("PERFTEST"+(rstring)getChannel());
		}

		(stream<rstring objectName> ObjNames) as MeasureWrite = Custom(ObjStSink as I; NumObjects as N) {
			logic state: {
				mutable boolean isStarted = false;
				mutable timestamp startTimestamp;
				mutable int32 numObjects = 0;
				mutable int32 numObjectsExpected = -1;
				mutable list<rstring> objNames;
			}
			onTuple I: {
				float64 duration = diffAsSecs(getTimestamp(),startTimestamp);
				printStringLn ("["+(rstring)getChannel()+"]"+"[WRITE] "+objectName+" bytes=" + (rstring)objectSize + ", duration="+(rstring)duration);
				isStarted = false;
				insertM(objNames, I.objectName, numObjects);
				numObjects++;
				if (numObjectsExpected == numObjects) {
					for (rstring name in objNames) {
						printStringLn ("["+(rstring)getChannel()+"]"+"[READ] "+name);
						submit ({objectName=name}, ObjNames);
					}
					numObjects = 0;
					numObjectsExpected = -1;
					clearM(objNames);
				}
			}
			onTuple N: {
				numObjectsExpected = N.numObjects;
			}
			onPunct I: { // time measurement start
				if (currentPunct() == Sys.WindowMarker) {
					if (!isStarted) { // start time measurement
						isStarted = true;
						startTimestamp = getTimestamp();
					}
				}
			}
			config placement: partitionColocation("PERFTEST"+(rstring)getChannel());
		}				
		
		stream<rstring data> ObjStSource = SwiftObjectStorageSource(ObjNames) { 
			param
				userID: $objectStorageUserID;
				password: $objectStoragePassword;
				projectID: $objectStorageProjectID;
				accessPoint: $objectStorageAccessPoint;
				container: $objectStorageContainer;
				vmArg : "-Xmx4096m";
				genOpenObjPunct: true;
			config placement: partitionColocation("PERFTEST"+(rstring)getChannel());
		}
	
		(stream<boolean dummy> EndStream;
		stream<uint32 count> Control
		) as MeasureRead = Custom(ObjStSource as I; NumObjects as N) {
			logic state: {
				mutable boolean isStarted = false;
				mutable timestamp startTimestamp;
				mutable int32 numObjects = 0;
				mutable int32 numObjectsExpected = -1;
			}
			onTuple I: {
				if (isStarted) { // test nature allows to measure on the first tuple
					float64 duration = diffAsSecs(getTimestamp(),startTimestamp);					
					printStringLn ("["+(rstring)getChannel()+"]"+"[READ] bytes=" + (rstring)length(data) + ", duration="+(rstring)duration);
					numObjects++;
					if (numObjects == numObjectsExpected) {
						submit({count = 1u}, Control); // tell gate to allow another tuple
						numObjects = 0;
						numObjectsExpected = -1;
					}
					// reset
					isStarted = false;	
				}
			}
			onTuple N: {
				numObjectsExpected = N.numObjects;
			}
			onPunct I: { // time measurement start
				if (!isStarted) { // start time measurement
					isStarted = true;
					startTimestamp = getTimestamp();
				}
			}
			config placement: partitionColocation("PERFTEST"+(rstring)getChannel());
		}
		
		() as CleanupTest = Custom(EndStream as I) {
			logic
			state: {
				mutable boolean res = initialize($objectStorageUserID, $objectStoragePassword, $objectStorageProjectID); // init Swift client
			}
			onTuple I: {
			}
			onPunct I: {
				if(currentPunct() == Sys.FinalMarker) {
					printStringLn ("FINAL PUNCT");
					if ($cleanup) {
						printStringLn ("["+(rstring)getChannel()+"]"+"Clean-up ...");
						deleteAllObjects($objectStorageContainer);

						printStringLn ("deleteContainer " + $objectStorageContainer);
						deleteContainer($objectStorageContainer);
					}
				}
			}
			config placement: partitionColocation("TEST-CONFIG");
		}
	
	
	config restartable: false;
}
